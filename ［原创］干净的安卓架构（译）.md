### ［原创］干净的安卓架构（译）
过去的几个月中，通过在Tuenti网站上与@pedro_g_s和@flipper83（两位大牛安卓开发）进行友好讨论之后，我决定是时候写一篇安卓应用架构的文章，目的在于和大家分享一些我在过去几个月中通过调查和实践学到的东西。
### 开始
写一款精品软件是有难度且很复杂的，质量很难把握，不止需要满足基本条件，同时需要满足软件的健壮性，可维护性，易测试性以及适应变化的灵活性，这时候，“清晰架构”就应运而生了，这一架构在开发任何软件应用的时候用起来非常顺手。思路很简单，“简洁架构”遵循以下原则：
- 框架独立性
- 可测试性
- UI独立性
- 数据独立性
- 外部依赖独立性
![Alt text](./1479533634042.png)

如图所示，我们并不要求一定要用四环结构，这只是一个示例图解，但是要考虑依赖项规则，代码依赖只能由外向内，内部不可以知道任何外部的事情。以下是一些相关名词解释，以便更好理解这种架构：
- Entities：应用的实体；
- Use Cases：是指结合数据流和实体中的用例，也称为Interactor；
- Interface Adapters：接口适配器，适配器将数据转换成各实体最方便的使用形式，Presenters和Controllers均属于这层；
- Frameworks和Drivers：这层包含所有的细节包括ui，工具，基础框架等。

### 场景
我会由一个简单的应用场景开始：创建一个简单的小app，从云端获取好友列表，当点击列表项打开另一个页面显示用户更多信息。
### Android应用架构
分离思想的目标是内部不知道任何外部内容的信息，它们能够不依赖任何外部元素被测试。为达到这个目标，我的方案把整个工程分为三层，每一层有它自己的作用并且相互之间独立工作。
值得一提的是每一层又有它自己的数据模型以实现独立性，从下图中你可以看到需要数据映射表来实现数据转换，这是为了不让数据模型贯穿整个应用要付出的代价，方案如下图：
![Alt text](./1479614863782.png)
注：除了用来解析json数据的gson，用来测试的junit，mockito，robolectric和espresso，我没有使用任何外部库，原因是尽可能使这个例子简单。但是在实际应用中不要犹豫使用任何依赖注入框架库或其它任何你熟悉的工具库等，这会使你的生活更简单（记住重复造轮子不是一个好选择）。
### 表现层 (Presentation Layer)
这一层关联着界面和动画相前的逻辑，这里仅用了一个Model View Presenter（下文简称MVP），你可以用MVC 或MVVM，这里我不再详述，fragments和activities在这里只是views，除了ui逻辑之外没有其它逻辑，这里也是所有render工作的地方。Presenter在 android UI 线程以外的新线程里工作，并通过回调将要渲染到View上的数据传递回来，如果你想看关于mvp和mvvm模型的好例子，请看我朋友的这篇文章。https://github.com/pedrovgs/EffectiveAndroidUI/
![Alt text](./1479795071472.png)

### 领域层 (Domain Layer)
业务逻辑都写在这一层，这里实现了所有的use case，这一层是一个纯粹的不带任何android依赖的java模型，所有外部组件通过接口的方式连接业务逻辑。
![Alt text](./1479627464840.png)

### 数据层 (Data Layer)
应用中需要的所有数据都来自这一层中的UserRepository实现（接口在领域层），主要策略是通过一个工厂根据一定的条件选取不同的数据来源。 举个例子，当通过id获取一个用户时，如果这个用户在缓存中已经存在，则硬盘缓存数据源会被选中，否则会通过向云端发起请求获取数据，然后存储到硬盘缓存。 
这个观点背后的原因是数据来源对于用户来说是透明的，用户不关心数据是从内存或disk或云端取到的，它们只关心数据是否被取到。

![Alt text](./1479627927819.png)

注：我的例子中使用了文件系统和android preferences非常简单和原生的disk缓存，再次提醒，如果已经有出色的库来做这些工作的话，不要重复造轮子。

### 错误处理
错误处理是一个长期待解决的讨论话题，如果你有任何不错的方法的话欢迎分享。我的方案是使用回调，因此如果data repository发生任何意外的话，回调中提供onResponse() onError()两个方法。ErrorBundle封装了异常处理，但这种方法带来的难处是当一个错误紧连着另一个错误发生时会带来一系列回调，直到回调到达表示层，同时代码的可读性也大打折扣。另外，如果出现错误，我本来可以通过事件总线系统抛出事件，但是这种实现方式类似于使用C语言的goto语法。在我看来，当你订阅多个事件时，如果不能很好的控制，你可能会被弄得晕头转向。
### 测试
关于测试我针对不同层采取了相应方法：
- 表示层：使用android instrumentation和 espresso进行集成和功能测试
- domain层：用于单元测试的JUnit和mockito
- 数据层：使用Robolectric （ 因为依赖于Android SDK中的类 ）进行集成测试和单元测试。
### 代码展示

我猜你现在在想，代码究竟在哪里呢？ 好吧，这就是你可以找到上述解决方案的github链接：https://github.com/android10/Android-CleanArchitecture。还要提一点，在文件夹结构方面，不同的层是通过以下不同的模块反应的:

- presentation: 展示层的Android模块
- domain: 一个没有android依赖的java模块
- data: 一个数据获取来源的android模块。
- data-test: 数据层测试，由于使用Robolectric 存在一些限制，所以得再独立的java模块中使用。

### 总结
就像bob大叔说的，“Architecture is About Intent, not Frameworks”，这点我非常同意，当然了，有很多不同的方法做不同的事情（不同的实现方法）我相信你和我一样也是每天面对很多挑战，但是通过应用这种方案，我相信你的应用会变得：
- 易维护
- 易测试
- 高聚合
- 低耦合
最后我强烈建议你实践一下这个例子，然后分享你的结果和经验或者其它你觉得更好的方式，持续的进步和提高自己是非常好的。我希望这篇文章对你有帮助，欢迎大家的反馈。
### 原文链接
http://fernandocejas.com/2014/09/03/architecting-android-the-clean-way/